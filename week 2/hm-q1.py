import mathimport osimport randomimport reimport systemp_bank_account = 0seb_bank_account = 0nic_bank_account = 0current_thread = ""seb_thread_acq = Falsenic_thread_acq = Falseclass lock():    def __init__(self):        self.lock_flag = False        self.thread_acq = ""    def acquire(self):        global current_thread        if self.lock_flag == False:            self.lock_flag = True            self.thread_acq = current_thread        else:            return "Locked"    def release(self):        self.lock_flag = False        self.thread_acq = ""# The class lock() contains the methods acquire() and release()bank_account = 0var_lock = lock()#%%def transaction(seb, nic):    # In this function you need to complete the code using some of the threading functions    # provided above. Assume that the loop continues running (thread continues running) until    # both Seb and Nic has completed their prearranged number of transactions    #    # In order to make the following function work you need to implement thread controls using    # the lock class implemented above (var_lock)    #    # Think about when each global variable is being used and how to handle multiple threads    # trying to access the global variable at the same time    #    # Try to describe what you think each line of the following code does in a live threading    # environment    global bank_account    global seb_thread_acq    global nic_thread_acq    global var_lock    global current_thread    seb_runs = seb    nic_runs = nic    while seb_runs > 0 or nic_runs > 0:        current_thread = run_thread(seb_runs, nic_runs) # who's take in the threads, return a user name, random                 var_status = thread_acquire_var(current_thread) # for this user, check the thread status for him, return a user name        if var_status == "Locked": # if locked, no action for this user;            continue        else:            var_lock.acquire()# if not locked, actions for this user        if var_lock.thread_acq == "Seb": #            if seb_thread_acq == False:                seb_runs += seb_thread()                seb_thread_acq = True                continue            else:                update_thread()                seb_thread_acq = False                seb_runs -= 1                var_lock.release()        else:            if nic_thread_acq == False:                nic_runs += nic_thread()                nic_thread_acq = True                continue            else:                update_thread()                nic_thread_acq = False                nic_runs -= 1                var_lock.release()    return bank_account#%%def seb_thread():    global var_lock    global temp_bank_account    global bank_account    if not var_lock.lock_flag or (var_lock.lock_flag and var_lock.thread_acq == "Seb"):        temp_bank_account = seb_bank_account + 1        return 0    else:        return 1# if it's in seb's thread or seb could occupy the thread, seb give bank 1 point, bank+1, seb no changedef nic_thread():    global var_lock    global temp_bank_account    global bank_account    if not var_lock.lock_flag or (var_lock.lock_flag and var_lock.thread_acq == "Nic"):        temp_bank_account = nic_bank_account - 1        return 0    else:        return 1# if it's in nick's thread or nick could occupy the thread, nicn takes bank 1 point, bank1-1, seb no changedef update_thread():    global bank_account    global temp_bank_account    bank_account = temp_bank_account# update the bank account with the tempdef thread_acquire_var(user):    global seb_bank_account    global nic_bank_account    global bank_account    global var_lock    if user == "Seb":        if (var_lock.lock_flag and var_lock.thread_acq == "Seb") or not var_lock.lock_flag:            seb_bank_account = bank_account            return "Seb"        else:            return "Locked"    else:        if (var_lock.lock_flag and var_lock.thread_acq == "Nic") or not var_lock.lock_flag:            nic_bank_account = bank_account            return "Nic"        else:            return "Locked"# return the thread's status, who thread or locked; update two persons' back accountdef run_thread(seb_runs, nic_runs):    if seb_runs == 0:        return "Nic"    if nic_runs == 0:        return "Seb"    rnd = random.random()    if rnd > 0.5:        return "Seb"    else:        return "Nic"# run the threadif __name__ == '__main__':    result = transaction(31495, 18374)    print (result)#%%#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Thu Jan 28 11:58:45 2021@author: meredithma"""def transaction(seb, nic):    # In this function you need to complete the code using some of the threading functions    # provided above. Assume that the loop continues running (thread continues running) until    # both Seb and Nic has completed their prearranged number of transactions    #    # In order to make the following function work you need to implement thread controls using    # the lock class implemented above (var_lock)    #    # Think about when each global variable is being used and how to handle multiple threads    # trying to access the global variable at the same time    #    # Try to describe what you think each line of the following code does in a live threading    # environment    global bank_account    global seb_thread_acq    global nic_thread_acq    global var_lock    global current_thread    seb_runs = seb    nic_runs = nic    while seb_runs > 0 or nic_runs > 0:        current_thread = run_thread(seb_runs, nic_runs) # who's take in the threads, return a user name, random         var_status = thread_acquire_var(current_thread) # for this user, check the thread status for him, return a user name        if var_status == "Locked": # if locked, no action for this user;            continue# if not locked, actions for this user        if current_thread == "Seb": # , change            if seb_thread_acq == False:                seb_runs += seb_thread()                seb_thread_acq = True                continue            else:                update_thread()                seb_thread_acq = False                seb_runs -= 1        else:            if nic_thread_acq == False:                nic_runs += nic_thread()                nic_thread_acq = True                continue            else:                update_thread()                nic_thread_acq = False                nic_runs -= 1    return bank_account